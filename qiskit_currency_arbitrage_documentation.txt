
Quantum Currency Arbitrage Detection using Qiskit
=================================================

Overview
--------
This project demonstrates how quantum computing can be applied to detect profitable currency arbitrage opportunities using the Quantum Approximate Optimization Algorithm (QAOA) implemented in Qiskit. The Python code models the currency exchange market as a directed graph and formulates the arbitrage detection problem as a Quadratic Unconstrained Binary Optimization (QUBO) problem. The QUBO is then solved using QAOA, a quantum algorithm designed for combinatorial optimization.

Relation to Quantum Computing
-----------------------------
The core quantum computing concepts used in this project are:

1. **QUBO (Quadratic Unconstrained Binary Optimization)**:
   - A mathematical formulation used to represent optimization problems where the objective is a quadratic function of binary variables.
   - QUBO is the standard input format for many quantum algorithms, including QAOA and quantum annealing.

2. **QAOA (Quantum Approximate Optimization Algorithm)**:
   - A hybrid quantum-classical algorithm that approximates solutions to combinatorial optimization problems.
   - It uses a parameterized quantum circuit (Ansatz) and a classical optimizer to find optimal parameters that minimize the cost function.
   - In this project, QAOA is used to find the optimal set of currency exchanges that maximize arbitrage profit.

Mapping the Flowchart to Qiskit Implementation
----------------------------------------------
The flowchart from the original notebook outlines the algorithmic steps. Here's how each step maps to the Qiskit-based implementation:

1. **Start**: Entry point of the script.
2. **Get the currency data**: Load exchange rates from a CSV file using pandas.
3. **nChooseK or custom method**: Not explicitly used; instead, all directed edges are considered.
4. **Create the objective and pass it to the nChooseK framework**: Objective function is constructed using negative logarithm of exchange rates.
5. **Formulate a problem as QUBO from objective functions**: Done using Qiskit's `QuadraticProgram`.
6. **Qiskit or D-Wave**: Qiskit is used in this implementation.
7. **Pass the QUBO to the D-Wave quantum annealer**: Not applicable; QAOA is used instead.
8. **Convert the QUBO to Sparse Pauli matrices**: Handled internally by Qiskit when solving with QAOA.
9. **Embed into the QAOA Ansatz**: QAOA circuit is constructed using the cost Hamiltonian derived from QUBO.
10. **Optimize the QAOA parameters {U(γ, α)} on real quantum computer**: Parameters are optimized using a classical optimizer (COBYLA).
11. **Create a quantum circuit with optimal parameters and measure**: Qiskit builds and simulates the circuit using `qasm_simulator`.
12. **Get the output in bitstring format**: Measurement results are collected and analyzed.
13. **Postprocess the solution to get the optimal currency arbitrage path**: Bitstring is mapped to selected currency exchange edges.
14. **Execute the trade**: Out of scope for this simulation.

Mathematical Formulation
------------------------

### Problem Definition

The currency arbitrage problem is modeled as finding an optimal cycle in a directed graph:

- Let **N** be the set of currencies.
- Let **r_ij** be the exchange rate from currency **i** to currency **j**.
- Define decision variable **b_ij ∈ {0, 1}** where:
  - **b_ij = 1** if edge (i, j) is part of the selected arbitrage cycle.
  - **b_ij = 0** otherwise.

### Objective Function

The goal is to maximize the product of exchange rates along a cycle. Using logarithms, this becomes an additive minimization problem:

    C = Σ_{i,j} [ -log(r_ij) * b_ij ]

### Constraint Penalty Function

To ensure a valid arbitrage cycle (exactly one incoming and one outgoing edge per currency):

    P = Σ_i ( (Σ_{j ≠ i} b_ji - 1)^2 ) + Σ_i ( (Σ_{j ≠ i} b_ij - 1)^2 )

Expanding this yields:

    P = Σ_i Σ_{j ≠ j'} b_ij * b_ij' + Σ_j Σ_{i ≠ i'} b_ij * b_i'j

- The first term ensures only one outgoing edge per currency.
- The second term ensures only one incoming edge per currency.

### Total Cost Function (QUBO)

The total cost function combines the objective and the penalty:

    C_total = C + m_p * P

Where **m_p** is a penalty factor that enforces the constraints.

### QUBO to Ising Transformation

For compatibility with quantum hardware, QUBO is transformed into an Ising model using:

    b_k = (1 - Z_k) / 2

Where **Z_k** is the Pauli-Z operator acting on qubit **k**.

- Linear terms: c_k * b_k = (c_k / 2) - (c_k / 2) * Z_k
- Quadratic terms: c_kl * b_k * b_l = (c_kl / 4)(1 - Z_k - Z_l + Z_k * Z_l)

This transformation allows the QUBO to be implemented as a quantum Hamiltonian in QAOA.

Conclusion
----------
This project demonstrates a practical application of quantum computing in finance. By modeling currency arbitrage as a QUBO and solving it with QAOA, we explore how quantum algorithms can tackle real-world optimization problems that are computationally hard for classical systems.
